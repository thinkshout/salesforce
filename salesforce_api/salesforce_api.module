<?php
// $Id$

/**
 * @file
 * Defines an API that enables modules to interact with the Salesforce server.
 *
 * 1. Get your security token.
 * 2. Get the Toolkit.
 * 3. Download your WSDL.
 */

// Define directory paths for the Toolkit and WSDL files.
define('SALESFORCE_DIR', drupal_get_path('module', 'salesforce_api'));
define('SALESFORCE_DIR_TOOLKIT', SALESFORCE_DIR .'/toolkit');
define('SALESFORCE_DIR_SOAPCLIENT', SALESFORCE_DIR_TOOLKIT .'/soapclient');
define('SALESFORCE_DIR_WSDL', SALESFORCE_DIR .'/wsdl');


// Define Drupal paths for various parts of the Salesforce UI.
define('SALESFORCE_PATH_ADMIN', 'admin/settings/salesforce');
define('SALESFORCE_PATH_FIELDMAPS', SALESFORCE_PATH_ADMIN .'/fieldmap');
define('SALESFORCE_PATH_DEMO', SALESFORCE_PATH_ADMIN .'/demo');
define('SALESFORCE_PATH_OBJECT', SALESFORCE_PATH_ADMIN .'/object');

// Salesforce schema properties.
// Not all these are in use yet.
define('SALESFORCE_FIELD_CREATEABLE', 1);
define('SALESFORCE_FIELD_DEFAULTEDONCREATE', 2);
define('SALESFORCE_FIELD_DEPRECATEDANDHIDDEN', 4);
define('SALESFORCE_FIELD_IDLOOKUP', 8);
define('SALESFORCE_FIELD_NILLABLE', 16);
define('SALESFORCE_FIELD_RESTRICTEDPICKLIST', 32);
define('SALESFORCE_FIELD_UNIQUE', 64);
define('SALESFORCE_FIELD_UPDATEABLE', 128);

// Bitmasks for the fields above
define('SALESFORCE_FIELD_SOURCE_ONLY', ~SALESFORCE_FIELD_CREATEABLE);
define('SALESFORCE_FIELD_REQUIRED', SALESFORCE_FIELD_CREATEABLE & ~SALESFORCE_FIELD_NILLABLE & ~SALESFORCE_FIELD_DEFAULTEDONCREATE);
define('SALESFORCE_FIELD_OPTIONAL', ~SALESFORCE_FIELD_REQUIRED & ~SALESFORCE_FIELD_SOURCE_ONLY);


// Define reporting levels for watchdog messages.
define('SALESFORCE_LOG_NONE', 0);
define('SALESFORCE_LOG_SOME', 5);
define('SALESFORCE_LOG_ALL', 10);


/**
 * Implementation of hook_menu().
 */
function salesforce_api_menu() {
  $items[SALESFORCE_PATH_ADMIN] = array(
    'title' => 'Salesforce',
    'description' => 'Administer settings related to your Salesforce integration.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_api_settings_form'),
    'access arguments' => array('administer salesforce'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'salesforce_api.admin.inc',
  );
  $items[SALESFORCE_PATH_ADMIN .'/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items[SALESFORCE_PATH_DEMO] = array(
    'title' => 'Test/Demo',
    'page callback' => 'salesforce_api_demo',
    'access arguments' => array('administer salesforce'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'salesforce_api.admin.inc',
  );
  $items[SALESFORCE_PATH_FIELDMAPS] = array(
    'title' => 'Fieldmaps',
    'description' => 'Administer fieldmap relationships between Drupal objects and Salesforce objects.',
    'page callback' => 'salesforce_api_fieldmap_admin',
    'access arguments' => array('administer salesforce'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'salesforce_api.admin.inc',
  );
  $items[SALESFORCE_PATH_FIELDMAPS .'/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('administer salesforce'),
    'weight' => 0,
  );
  $items[SALESFORCE_PATH_FIELDMAPS .'/add'] = array(
    'title' => 'Add',
    'description' => 'Create a new fieldmap.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_api_fieldmap_add_form'),
    'access arguments' => array('administer salesforce'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
    'file' => 'salesforce_api.admin.inc',
  );
  $items[SALESFORCE_PATH_FIELDMAPS .'/%/edit'] = array(
    'title' => 'Edit fieldmap',
    'description' => 'Edit an existing fieldmap.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_api_fieldmap_edit_form', 4),
    'access arguments' => array('administer salesforce'),
    'type' => MENU_CALLBACK,
    'file' => 'salesforce_api.admin.inc',
  );
  $items[SALESFORCE_PATH_FIELDMAPS .'/%/clone'] = array(
    'title' => 'Clone a fieldmap',
    'description' => 'Clone an existing fieldmap.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_api_fieldmap_clone_form', 4),
    'access arguments' => array('administer salesforce'),
    'type' => MENU_CALLBACK,
    'file' => 'salesforce_api.admin.inc',
  );
  $items[SALESFORCE_PATH_FIELDMAPS .'/%/delete'] = array(
    'title' => 'Delete fieldmap',
    'description' => 'Delete an existing fieldmap.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_api_fieldmap_delete_form', 4),
    'access arguments' => array('administer salesforce'),
    'type' => MENU_CALLBACK,
    'file' => 'salesforce_api.admin.inc',
  );
  $items[SALESFORCE_PATH_OBJECT] = array(
    'title' => 'Object setup',
    'description' => 'Define which SalesForce objects you would like to be available in your Drupal site.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_api_admin_object'),
    'access arguments' => array('administer salesforce'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'salesforce_api.admin.inc',
  );
  $items[SALESFORCE_PATH_OBJECT .'/%'] = array(
    'title' => 'Object setup',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_api_admin_object_settings', count(explode('/', SALESFORCE_PATH_OBJECT))),
    'access arguments' => array('administer salesforce'),
    'type' => MENU_CALLBACK,
    'file' => 'salesforce_api.admin.inc',
  );
  return $items;
}

/**
 * Implementation of hook_perm().
 */
function salesforce_api_perm() {
  return array('administer salesforce');
}

/**
 * Creates an object used for communicating with the Salesforce server and
 *   performs a login to verify the API credentials.
 *
 * @param $username
 *   Username for Salesforce. An email address, most likely. If none passed,
 *     sitewide creds will be used
 * @param $password
 *   Password to Salesforce account.
 * @param $token
 *   Security token from Salesforce.
 * @param $reconnect
 *   By default, subsequent calls to this function will return the same, already
 *     connected Salesforce object as preceding calls. Setting this variable to
 *     TRUE will cause a new connection to be established instead.
 * @return
 *   The DrupalSalesforce object used to communicate with the Salesforce server
 *     if successful or FALSE if a connection could not be established.
 */
function salesforce_api_connect($username = FALSE, $password = FALSE, $token = FALSE, $reconnect = FALSE) {
  static $sf = FALSE;

  // Return the previously connected object.
  if ($sf && !$reconnect) {
    return $sf;
  }

  // Boolean, whether we are connecting with the default website user or not.
  $default_site_user = !$username;

  // Load up the sitewide API credentials if no others were provided:
  $username = $username ? $username : variable_get('salesforce_api_username', '');
  $password = $password ? $password : variable_get('salesforce_api_password', '');
  $token = $token ? $token : variable_get('salesforce_api_token', '');

  // Include the file that defines the class.
  require_once(drupal_get_path('module', 'salesforce_api') .'/salesforce.class.inc');

  // Fail early if we didn't receive an API username, password, or token.
  if (empty($username) || empty($password) || empty($token)) {
    DrupalSalesforce::watchdog(SALESFORCE_LOG_SOME, 'Connection to Salesforce failed because API credentials have not been set.', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  // Create a new Salesforce object with the API credentials.
  $sf = new DrupalSalesforce($username, $password, $token);

  // Attempt a login.
  if ($sf->login()) {
    // Mimick expired password state to debug.
    // $sf->login->passwordExpired = TRUE;
    if ($sf->login->passwordExpired) {
      if ($default_site_user) {
        salesforce_api_reset_expired_password($sf);
      }
      else {
        drupal_set_message(t('Your Salesforce account password expired.  Please <a href="https://login.salesforce.com/">click here to login to Salesforce.com</a> and change your password.'));
      }
    }
  }
  else {
    // Or return FALSE to indicate the failure.
    $sf = FALSE;
  }
  return $sf;
}

/**
 * Helper function for salesforce_api_connect() to reset an expired password,
 *   for the website's default salesforce user only.
 *
 * @param $sf
 *   The logged in DrupalSalesforce object with an expired password.
 * @return
 *   void
 */
function salesforce_api_reset_expired_password($sf) {
  // Append one letter and one digit to the password to make sure we meet
  // salesforce's password validation requirements.
  $new_password = user_password() .'z9';
  // setPassword() may throw InvalidIdFault or UnexpectedErrorFault exceptions.
  $sf->client->setPassword($sf->login->userId, $new_password);
  variable_set('salesforce_api_password', $new_password);
  // Salesforce changes the security token when the password gets changed and
  // sends an email with the new security token.  The new security token can
  // not be retrieved via the API.
  variable_del('salesforce_api_token');

  // Log the event and alert admins about required steps to complete.
  $vars = array(
    '%user' => $sf->login->userInfo->userFullName,
    '%email' => $sf->login->userInfo->userEmail,
    '!uri' => url(SALESFORCE_PATH_ADMIN, array('absolute' => TRUE)),
  );

  DrupalSalesforce::watchdog(SALESFORCE_LOG_ALL, 'The password for the salesforce account %user expired.  Drupal changed it and saved the new password.  Salesforce updated the security token and emailed it to %email.', $vars);
  DrupalSalesforce::watchdog(SALESFORCE_LOG_SOME, 'Provide the new security token at <a href="!uri">Drupal\'s Salesforce settings page</a>.  Salesforce emailed it to %email.', $vars, WATCHDOG_ALERT);

  // If salesforce connects on pages for anonymous users then these messages should not be displayed.
  if (user_access('administer salesforce')) {
    drupal_set_message(t('The password for the salesforce account %user expired.  Drupal changed it and saved the new password.  Salesforce updated the security token and emailed it to %email.', $vars));
    drupal_set_message(t('Provide the new security token at <a href="!uri">Drupal\'s Salesforce settings page</a>.  Salesforce emailed it to %email.', $vars), 'error');
  }
}

/**
 * Implementation of hook_fieldmap_objects().
 *
 * This will pull a cached version (if possible) of the available SF fields for
 * the object(s) in question. Prevent excess querying!
 */
function salesforce_api_fieldmap_objects($type = 'salesforce') {
  $objects = array();
  // Define the data fields available for Salesforce objects.
  if ($type == 'salesforce') {
    $cache = cache_get('salesforce_api_sf_objects');
    if ($cache->data == '') {
      $objects = salesforce_api_cache_build();
    }
    else {
      $objects = $cache->data;
    }
  }
  return $objects;
}

/**
 * Recreate the salesforce object cache
 */
function salesforce_api_cache_build() {
  $sf_objects = variable_get('salesforce_api_enabled_objects', array('Campaign', 'Contact', 'Lead'));
  $sf = salesforce_api_connect();
  $result = salesforce_api_describeSObjects($sf_objects);
  foreach ($sf_objects as $i => $obj) {
    $objects[$obj] = salesforce_api_object_to_fieldmap_fields($result[$obj]);
  }

  // find the expiry time
  $lifetime = variable_get('salesforce_api_object_expire', CACHE_PERMANENT);
  $expire = ($lifetime == CACHE_PERMANENT) ? CACHE_PERMANENT : time() + $lifetime;
  cache_set('salesforce_api_sf_objects', $objects, $table = 'cache', $expire, $headers = NULL);
  drupal_set_message(t('Salesforce object cache has been refreshed.'));
  return $objects;
}

/**
 * Returns an array of system fields that are retrievable from Salesforce.
 */
function salesforce_api_fieldmap_system_fields() {
  $fields = array(
    'Id' => array('label' => t('Salesforce ID')),
    'IsDeleted' => array('label' => t('Is the object deleted?')),
    'CreatedById' => array('label' => t('User ID of the creator')),
    'CreatedDate' => array('label' => t('Creation date and time')),
    'LastModifiedById' => array('label' => t('User ID of the last modifier')),
    'LastModifiedDate' => array('label' => t('Last user modification date and time')),
    'SystemModstamp' => array('label' => t('Last user or system modification date and time')),
  );

  return $fields;
}


/**
 * Saves a fieldmap to the database.
 *
 * @param $map;
 *   An array containing the fieldmap data using the following keys and values:
 *   - fieldmap: the numeric index of the fieldmap.
 *   - drupal: the name of a Drupal object.
 *   - salesforce: the name of a Salesforce object.
 *   - automatic: whether or not the sync should be automatic
 *   - description: a short title or description of the fieldmap
 *   - fields: an array that maps source fields (as keys) to their corresponding
 *       target fields (as values).
 */
function salesforce_api_fieldmap_save(&$map) {
  if ($map['fieldmap']) {
    $primary_keys = array('fieldmap');
  }
  if (is_array($map['fields'])) {
    $map['fields'] = serialize($map['fields']);
  }
  drupal_write_record('salesforce_field_map', $map, $primary_keys);
}

/**
 * Loads a fieldmap from the database.
 *
 * @param $fieldmap
 *   The index of the fieldmap to load.
 * @return
 *   An array containing the fieldmap data.
 */
function salesforce_api_fieldmap_load($fieldmap) {
  static $maps;
  if (!isset($maps[$fieldmap]) && $fieldmap != '') {
    $result = db_query("SELECT * FROM {salesforce_field_map} WHERE fieldmap = %d", $fieldmap);
    $map = db_fetch_array($result);
    if (isset($map['fields'])) {
      $map['fields'] = unserialize($map['fields']);
    }
    $maps[$fieldmap] = $map;
  }

  return $maps[$fieldmap];
}

/**
 * Remove a field from all fieldmaps. This is particularly useful for implementations
 * of hook_content_fieldapi('delete instance'). May be use to delete an occurence
 * in a single fieldmap (by supplying drupal_type and/or salesforce_type), or every 
 * occurence in all fieldmaps (by supplying only fieldname).
 *
 * @param $fieldname
 *  The name of the field to be deleted. Either a CCK field, or a Salesforce field
 * @param $drupal_type (optional)
 *  If given, limit deleting of the field to this Drupal content type
 * @param $salesforce_type (optional)
 *  If given, limit
 * @see sf_node/sf_node.module:sf_node_content_fieldapi
 * @todo I'm sure this can be done more elegantly, but I can't spend anymore braincells on it right now.
 */
function salesforce_api_fieldmap_field_delete($fieldname, $drupal_type = null, $salesforce_type = null) {
  if ($drupal_type && $salesforce_type) {
    $result = db_query('SELECT fieldmap FROM {salesforce_field_map} WHERE drupal = "%s" AND salesforce = "%s"', $drupal_type, $salesforce_type);
  }
  elseif ($drupal_type) {
    $result = db_query('SELECT fieldmap FROM {salesforce_field_map} WHERE drupal = "%s"', $drupal_type);
  } 
  elseif ($salesforce_type) {
    $result = db_query('SELECT fieldmap FROM {salesforce_field_map} WHERE salesforce = "%s"', $salesforce_type);
  } 
  else {
    $result = db_query('SELECT fieldmap FROM {salesforce_field_map}');
  }
  
  while ($fieldmap_id = db_result($result)) {
    $map = salesforce_api_fieldmap_load($fieldmap_id);
    // In the extremely unlikely event that a Salesforce field and a Drupal
    // field share the same name, this function handles both.
    if ($drupal_type) {
      $key1 = array_search($fieldname, $map['fields']);
      if ($key1) {
        unset($map['fields'][$key1]);
        drupal_set_message(t('Removed Drupal field from salesforce_api !link',
          array('!link' => l('fieldmap ' . $fieldmap_id, SALESFORCE_PATH_OBJECT . '/' . $fieldmap_id))));
        salesforce_api_fieldmap_save($map);
      }
    }
    if ($salesforce_type) {
      if (!empty($map['fields'][$key2])) {
        unset($map['fields'][$key2]);
        drupal_set_message(t('Removed Salesforce field from salesforce_api !link',
          array('@link' => l('fieldmap ' . $fieldmap_id, SALESFORCE_PATH_OBJECT . '/' . $fieldmap_id))));
        salesforce_api_fieldmap_save($map);
      }
    }
  }
}

/**
 * Clones a fieldmap.
 *
 * @param $fieldmap
 *   The index of the fieldmap to clone.
 * @return
 *   The newly created fieldmap or FALSE if the clone failed.
 */
function salesforce_api_fieldmap_clone($fieldmap) {
  // Load the fieldmap from the database.
  $map = salesforce_api_fieldmap_load($fieldmap);

  // Return FALSE if the source fieldmap does not exist.
  if (empty($map)) {
    return FALSE;
  }
  // Save the old fieldmap id, save a new one, and return the new one.
  unset($map['fieldmap']);
  salesforce_api_fieldmap_save($map);
  return !empty($map['fieldmap']) ? $map : FALSE;
}

/**
 * Deletes a fieldmap from the database.
 *
 * @param $fieldmap
 *   The index of the fieldmap to delete.
 */
function salesforce_api_fieldmap_delete($fieldmap) {
  db_query("DELETE FROM {salesforce_field_map} WHERE fieldmap = %d", $fieldmap);
  db_query("DELETE FROM {salesforce_object_map} WHERE fieldmap = %d", $fieldmap);
  if (function_exists('sf_prematch_match_by_delete')) {
    sf_prematch_match_by_delete($fieldmap);
  }
}

/**
 * Returns an array of fieldmaps for use as options in the Forms API.
 *
 * @param $drupal
 *   Filters the fieldmaps by Drupal object.
 * @param $salesforce
 *   Filters the fieldmaps by Salesforce object.
 * @param $automatic
 *   Optional: Filter the fieldmaps to only pull those marked automatic.
 * @return
 *   A FAPI options array of all the matching fieldmaps.
 */
function salesforce_api_fieldmap_options($drupal = NULL, $salesforce = NULL) {
  $options = array();

  // This does not need to not be optimized for perfomance since it's only an admin interface.
  $vars = array($drupal ? $drupal : '%', $salesforce ? $salesforce : '%');
  $result = db_query("SELECT fieldmap, drupal, salesforce FROM {salesforce_field_map} WHERE drupal LIKE '%s' AND salesforce LIKE '%s'", $vars);

  while ($map = db_fetch_array($result)) {
     // Setup some replacement args for the label.
     $args = array(
       '@drupal' => salesforce_api_fieldmap_object_label('drupal', $map['drupal']),
       '@salesforce' => salesforce_api_fieldmap_object_label('salesforce', $map['salesforce']),
       );
    $options[$map['fieldmap']] = t('Drupal @drupal to Salesforce @salesforce', $args);
  }

  return $options;
}

/**
 * Returns all or a subset of the objects defined via hook_sf_fieldmap().
 *
 * @param $type
 *   Specify a type to filter the return value to objects of that type.
 * @param $name
 *   Specify an object name to filter the return value to that object alone.
 *     If this parameter is supplied, you must specify the correct type as well.
 * @return
 *   An array of all objects sorted by type with no arguments.  Otherwise an
 *     array of objects filtered as specified by the parameters.
 */
function salesforce_api_fieldmap_objects_load($type = NULL, $name = NULL) {
  static $objects = array();

  // If we have not yet cached the object definitions...
  if (empty($objects)) {
    // Find all the Drupal objects defined by hook_sf_fieldmap().
    $objects['drupal'] = module_invoke_all('fieldmap_objects', 'drupal');

    // Get all the Salesforce objects defined by hook_sf_fieldmap().
    $objects['salesforce'] = module_invoke_all('fieldmap_objects', 'salesforce');

    // Allow other modules to modify the object definitions.
    foreach (module_implements('fieldmap_objects_alter') as $module) {
      $function = $module .'_fieldmap_objects_alter';
      $function($objects);
    }
  }

  // If a particular object type was specified...
  if (!empty($type)) {
    // And a particular object was specified...
    if (!empty($name)) {
      // Return that object definition if it exists or FALSE if it does not.
      if (isset($objects[$type][$name])) {
        return $objects[$type][$name];
      }
      else {
        return FALSE;
      }
    }
    else {
      // If no object was specified, return all objects of the specified type or
      // FALSE if the type does not exist
      if (isset($objects[$type])) {
        return $objects[$type];
      }
      else {
        return FALSE;
      }
    }
  }


  return $objects;
}

/**
 * Returns the label for the object of the specified type and name.
 */
function salesforce_api_fieldmap_object_label($type, $name) {
  // Get the object definition.
  $object = salesforce_api_fieldmap_objects_load($type, $name);

  // If no label is specified, return the object name.
  if (empty($object['label'])) {
    return check_plain($name);
  }

  return $object['label'];
}

// Returns a string of description text for the specified fieldmap.
function salesforce_api_fieldmap_description() {
  return t('Fieldmap @index maps Salesforce %salesforce objects to Drupal %drupal objects.', array('@index' => $map['fieldmap'], '%drupal' => salesforce_api_fieldmap_object_label('drupal', $map['drupal']), '%salesforce' => salesforce_api_fieldmap_object_label('salesforce', $map['salesforce'])));
}

/**
 * Returns a FAPI options array for specifying a field from the source object to
 *   associate with the target field.
 *
 * @param $object
 *   The source object whose fields we need to filter into the options array.
 * @param $type
 *   The type of the target field's object.
 * @param $name
 *   The name of the target object.
 * @param $field
 *   The name of the target field.
 * @return
 *   A FAPI options array of all the available fields that can map to the
 *     target field.
 */
function salesforce_api_fieldmap_field_options($object, $type = NULL, $name = NULL, $field = NULL) {
  // Define the options array with a blank value.
  $options = array('' => '');

  // TODO: Consider filtering these based on the object definition.  For now
  // this function simply uses any field defined for the source object.

  // Loop through all the fields of the source object.
  foreach ($object['fields'] as $key => $data) {
    // Add the field to the options array in the right options group.
    if (!empty($data['group'])) {
      $options[$data['group']][$key] = $data['label'];
    }
    else {
      $options[t('Core fields')][$key] = $data['label'];
    }
  }

  return $options;
}

/**
 * Creates an object for export to Salesforce based on the supplied Drupal
 *   object and fieldmap.
 *
 * @param $fieldmap
 *   The index of the fieldmap used to filter the Drupal object into the export.
 * @param $drupal_data
 *   The Drupal object used to generate the export.
 * @return
 *   An object containing data ready for export to Salesforce or FALSE if
 *     the operation failed.
 */
function salesforce_api_fieldmap_export_create($fieldmap, $drupal_data = NULL) {
  // Load the fieldmap from the database.
  $map = salesforce_api_fieldmap_load($fieldmap);

  // Fail if the fieldmap does not exist.
  if (!$map) {
    return FALSE;
  }

  $drupal_object_definition = salesforce_api_fieldmap_objects_load('drupal', $map['drupal']);
  $sf_object_definition = salesforce_api_fieldmap_objects_load('salesforce', $map['salesforce']);
  $object = new stdClass();

  // Loop through the fields on the fieldmap.
  foreach ($map['fields'] as $sf_fieldname => $drupal_fieldname) {
    $sf_field_definition = $sf_object_definition['fields'][$sf_fieldname];
    $updateable = $sf_field_definition['type'] & SALESFORCE_FIELD_UPDATEABLE;
    $createable = $sf_field_definition['type'] & SALESFORCE_FIELD_CREATEABLE;

    // Don't try to update or create fields to which those actions do not apply.
    if ((!$updateable && !$createable)
    || (empty($drupal_data->salesforce['sfid']) && !$createable)
    || (!empty($drupal_data->salesforce['sfid']) && !$updateable)) {
      continue;
    }

    // If a handler is specified for retrieving a value for the Drupal field...
    if (isset($drupal_object_definition['fields'][$drupal_fieldname]['export'])) {
      $drupal_field_export_handler = $drupal_object_definition['fields'][$drupal_fieldname]['export'];
      $drupal_field_definition = $drupal_object_definition['fields'][$drupal_fieldname];
      // Get the value for the field from the handler function.
      $object->$sf_fieldname = htmlentities($drupal_field_export_handler($drupal_data, $drupal_fieldname, $drupal_field_definition, $sf_field_definition));
    }
    // Otherwise set the field on the export object to the value of the Drupal
    // field if it's present on the source object.
    elseif (isset($drupal_data->$drupal_fieldname)) {
      $object->$sf_fieldname = htmlentities($drupal_data->$drupal_fieldname);
    }
  }

  // Before we return the object, we need to check for any fieldsToNull.
  // Leaving a field blank will not erase an existing value from Salesforce.
  // Any such value must be explicitly set to null.
  // TODO: Fields should be checked for nillable before getting added to fieldsToNull
  $props = get_object_vars($object);
  foreach ($props as $key => $value) {
    $sf_field_definition = $sf_object_definition['fields'][$sf_fieldname];
    // Salesforce treats the following values differently than null.
    if ($value === FALSE || $value === 0 || $value === '0' || $value === 'false') {
      $object->$key = $value = 0;
    } elseif(empty($value)) {
      $nillable = $sf_field_definition['type'] & SALESFORCE_FIELD_NILLABLE;
      // If the field is not nillable, don't try to set it to null
      if (!$nillable) {
        switch ($sf_field_definition['salesforce']['type']) {
          case 'boolean': 
            $object->$key = 0;
            break;
          case 'string':
            $object->$key = t('(blank)');
            break;
          default:
            unset($object->$key);
            break;
        }
      } else {
        $object->fieldsToNull = $key;
        // Enterprise client can only null one field per transaction.
        // This is a bug beyond our control. For now, we just have to deal with it.
        // The following doesn't actually work:
        // if (!empty($object->fieldsToNull)) { 
        //   $object->fieldsToNull .= '; '; 
        // }
      }
    }
  }
  return $object;
}

/**
 * Loads the Salesforce ID and fieldmap index of a Drupal object.
 *
 * @param $type
 *   The type of the Drupal object you are requesting data for; node or user.
 * @param $id
 *   The associated unique ID used to identify the object in Drupal.
 * @return
 *   An array containing the associated Salesforce object type and ID or an
 *     empty array if no data was found.
 */
function salesforce_api_id_load($type, $id) {
  // Query the main ID table for the associated data.
  $result = db_query("SELECT sfid, fieldmap FROM {salesforce_object_map} WHERE drupal_type = '%s' AND oid = %d", $type, $id);

  // Return an empty array if no data was found.
  if (!$data = db_fetch_array($result)) {
    return array();
  }
  else {
    // Otherwise return the Salesforce object type and ID.
    return $data;
  }
}

/**
 * Saves the Salesforce ID and fieldmap index of a Drupal object.
 *
 * @param $drupal_type
 *   The type of the Drupal object you are requesting data for; node or user.
 * @param $oid
 *   The associated unique ID used to identify the object in Drupal.
 * @param $sfid
 *   The Salesforce ID of the associated object in the Salesforce database.
 * @param $fieldmap
 *   The index of the fieldmap used to generate the export.
 */
function salesforce_api_id_save($drupal_type, $oid, $sfid, $fieldmap) {
  db_query("DELETE FROM {salesforce_object_map} WHERE drupal_type = '%s' AND oid = %d", $drupal_type, $oid);
  db_query("INSERT INTO {salesforce_object_map} (drupal_type, oid, sfid, fieldmap) VALUES ('%s', %d, '%s', %d)", $drupal_type, $oid, $sfid, $fieldmap);
}

function salesforce_api_search_for_duplicates($direction, $fieldmap_type, $object, $fieldmap_id) {
  // Call hook_sf_find_match to give opportunity to try to match existing sf object instead
  // of creating a new one. No hook_sf_find_match is defined out of the box. Developers must
  // implement their own logic for this one.
  return module_invoke_all('sf_find_match', $direction, $fieldmap_type, $object, $fieldmap_id);
}

/**
 * Implementation of hook_theme().
 *
 * Registers theme callback for admin screen
 */
function salesforce_api_theme($existing, $type, $theme, $path) {
  return array(
    'salesforce_api_fieldmap_edit_form_table' => array(
      'file' => 'salesforce_api.admin.inc',
      'arguments' => array('form' => NULL),
    ),
    'salesforce_api_object_options' => array(
      'arguments' => array('element' => NULL)
    ),
  );
}

/**
 * Wrapper for SOAP SforceBaseClient::describeGlobal
 * @return an SFQueryResult object (look at ->types for an array of SF object types)
 */
function salesforce_api_describeGlobal() {
  static $response;
  if (!empty($response)) {
    return $response;
  }
  $sf = salesforce_api_connect();
  if ($sf === FALSE) {
    $link = l('Please verify that you have completed your SalesForce credentials', SALESFORCE_PATH_ADMIN);
    drupal_set_message(t('Unable to connect to SalesForce. !link', array('!link' => $link)), 'error');
    return;
  }
  $response = $sf->client->describeGlobal();
  if (isset($response->sobjects)) {
    $response->types = $response->sobjects;
    unset($response->sobjects);
  }
  return $response;
}

/**
 * Convert Salesforce object fields to fieldmap array for saving
 */
function salesforce_api_object_to_fieldmap_fields($object)  {
  $fieldmap_object = array(
    'label' => t($object->label),
    'fields' => array()
  );
  foreach ($object->fields as $field) {
    $properties = array('name', 'label', 'type', 'length', 'soapType');
    $booleans = array('createable', 'defaultedOnCreate', 'deprecatedAndHidden',
      'idLookup', 'nillable', 'restrictedPicklist', 'unique', 'updateable');
    $source = get_object_vars($field);
    $sf_definition = array_intersect_key($source, array_flip($properties));
    foreach ($booleans as $bool) {
      $sf_definition['sf_type'] |= (int)$source[$bool] * constant('SALESFORCE_FIELD_' . strtoupper($bool));
    }
    $fieldmap_object['fields'][$field->name] = array(
      'name' => $sf_definition['name'],
      'label' => $sf_definition['label'],
      'type' => $sf_definition['sf_type'],
      'salesforce' => $sf_definition,
      );
  }
  return $fieldmap_object;
}

/**
 * Implementation of hook_cron().
 */
function salesforce_api_cron() {
  $cache = cache_get('salesforce_api_sf_objects');
  // if the cache has already been delete or is expired then rebuild
  if (!$cache || time() > $cache->expire) salesforce_api_cache_build();
  return;
}


/**
 * Wrapper for SOAP SforceBaseClient::describeSObject
 * Given an sf object type, return the SF Object definition
 * @param string type : the machine-readable name of the SF object type
**/
function salesforce_api_describeSObject($type) {
  if (!is_string($type)) {
    drupal_set_message(t('DescribeSObject expects a string. ' . gettype($type) . ' received.'), 'error');
    return false;
  }

  $objects = salesforce_api_describeSObjects($type);
  if(!empty($objects[$type])) {
    return $objects[$type];
  } else {
    drupal_set_message(t('DescribeSObject failed to find ' . $type), 'error');
    return false;
  }
}

/**
 * Wrapper for SOAP SforceBaseClient::describeSObjects
 * Given an array of sf object type, return an associative, normalized array of
 * SF object definitions, indexed on machine-readable names of SObjects
 * @param array types : an array of machine-readable names to SObjects
 */
function salesforce_api_describeSObjects($types) {
  static $objects;
  if (is_string($types)) {
    $types = array($types);
  }
  if (!is_array($types)) {
    drupal_set_message(t('DescribeSObjects expects an array. ' . gettype($types) . ' received.'), 'error');
    return false;
  }

  // There is no reason to describe the same object twice in one HTTP request.
  // Use a static cache to save API calls and bandwidth.
  if (!empty($objects)) {
    $outstanding = array_diff($types, array_keys($objects));
    if (empty($outstanding)) {
      $ret = array();
      foreach ($types as $k) {
        $ret[$k] = $objects[$k];
      }
      return $ret;
    }
  }

  if (is_string($types)) {
    $types = array($types);
  }

  try {
    $sf = salesforce_api_connect();
    if ($sf === FALSE) {
      $link = l('Please verify that you have completed your SalesForce credentials', SALESFORCE_PATH_ADMIN);
      drupal_set_message(t('Unable to connect to SalesForce. !link', array('!link' => $link)), 'error');
      return;
    }
    $objects = $sf->client->describeSObjects(array_values($types));
  } catch (Exception $e) {
    DrupalSalesforce::watchdog(SALESFORCE_LOG_SOME, 'Unable to establish Salesforce connection while issuing describeSObjects API call.', array(), WATCHDOG_ERROR);
  }
  if (empty($objects)) {
    return array();
  }

  // This is the normalization part: If only one object was described, SalesForce
  // returned an object instead of an array. ALWAYS return an array of objects.
  if (is_object($objects)) {
    $objects = array($objects);
  }

  // And make it an associative array for good measure.
  $tmp = array();
  foreach ($objects as $o) {
    $tmp[$o->name] = $o;
  }
  $objects = $tmp;
  return $objects;
}

